/**
 *
 * Copyright (c) 2022 UPMEM.
 *
 */

#ifndef __GI_CMD_H__
#define __GI_CMD_H__

#include "bitops.h"

#ifdef DEBUG
/*
 * TODO This define as well as the related code must be deleted
 * There is a bug in the GI, this define will be used to verify the fix
*/
//#define GI_ERROR
#endif

/* -------------------
 * Answer definition
 * -------------------
 * when PILOT transmits a 16-bits word on MOSI line through SPI interface,
 * the DPU-DRAM transmits at the same time a 16-bits answer on MISO line
 * whom the bitfield is described as follows:
 *
 * [15] Word Odd Parity Flag of previously received SPI word
 * [14] Word Odd Parity Flag of previously received SPI word
 * [13] Word Odd Parity Flag of previously received SPI word
 * [12] Result Valid Flag
 * [11] Result Valid Flag
 * [10] Result Valid Flag
 * [9] Reserved - 0b0
 * [8] Odd Parity Flag of Result data (RESULT[7:0])
 * [7:0] Result data (RESULT[7:0])
 */

#define GI_RESPONSE_GET_PREVIOUS_ODD_FLAG(x) ((x & 0xE000) >> 13)
#define GI_RESPONSE_GET_RESULT_VALID_FLAG(x) ((x & 0x1C00) >> 10)
#define GI_RESPONSE_GET_RESERVED(x)          ((x & 0x0200) >> 9)
#define GI_RESPONSE_GET_ODD_FLAG(x)          ((x & 0x0100) >> 8)
#define GI_RESPONSE_GET_RESULT(x)            ((x & 0x00FF) >> 0)

/* -------------------
 * Words definition
 * -------------------
*/
/* Words type */
#define WORD_CMD_1	(0x1 << 12)
#define WORD_CMD_3	(0x3 << 12)
#define WORD_CMD_6	(0x6 << 12)
#define WORD_CMD_7	(0x7 << 12)
#define WORD_CMD_C	(0xC << 12)
#define WORD_CMD_E	(0xE << 12)

#define WORD_ESC_5	(0x5 << 12)
#define WORD_ESC_8	(0x8 << 12)

#define WORD_INSTR	(0xA << 12)

/* Slave node indexes (AKA DPU IDs) */
#define DPU_ID_0	(0x0)
#define DPU_ID_1	(0x1)
#define DPU_ID_2	(0x2)
#define DPU_ID_3	(0x3)
#define DPU_ID_4	(0x4)
#define DPU_ID_5	(0x5)
#define DPU_ID_6	(0x6)
#define DPU_ID_7	(0x7)
#define DPU_NR		(0x8)

/* Parity bit logic */
#define EVEN_PARITY(word)		(~(odd_parity(word)) & 1)

#define AB_BITS_DELTA(word)		((popcount(word) < 3 ) ? (word | (((1 << (3 - popcount(word))) -1) << 8)) : word )
#define AB_PARITY(word)			((word & (1 << 8)) ? (word | EVEN_PARITY(word) << 9) : (word | EVEN_PARITY(word) << 8))

#define SET_AB(word)			(AB_PARITY(AB_BITS_DELTA(word)))
#define SET_MSB_PARITY(word)		(word |  EVEN_PARITY(word) << 12)

/* CMD GET_1RESULT */
#define LNKE_CTRL_REG_ID_LSB_ADDR		(0x0)
#define LNKE_CTRL_REG_ID_MSB_ADDR		(0x1)
#define LNKE_CTRL_REG_PLL_LOCK_ADDR		(0x2)
#define LNKE_CTRL_REG_CHECK_OUTCOME_ADDR	(0x3)
#define LNKE_CTRL_REG_TEMP_CONF_DEFECT_ADDR	(0x4)
#define LNKE_CTRL_REG_TEMP_ADDR			(0x5)


#define CMD_GET_1RESULT_CHIP_ID_LSB		(SET_AB(WORD_CMD_1 | LNKE_CTRL_REG_ID_LSB_ADDR))
#define CMD_GET_1RESULT_CHIP_ID_MSB		(SET_AB(WORD_CMD_1 | LNKE_CTRL_REG_ID_MSB_ADDR))
#define CMD_GET_1RESULT_PLL_LOCK		(SET_AB(WORD_CMD_1 | LNKE_CTRL_REG_PLL_LOCK_ADDR))
#define CMD_GET_1RESULT_CHECK_RES_OUTCOME	(SET_AB(WORD_CMD_1 | LNKE_CTRL_REG_CHECK_OUTCOME_ADDR))
#define CMD_GET_1RESULT_TEMP_CONF_DEFECT	(SET_AB(WORD_CMD_1 | LNKE_CTRL_REG_TEMP_CONF_DEFECT_ADDR))
#define CMD_GET_1RESULT_TEMP			(SET_AB(WORD_CMD_1 | LNKE_CTRL_REG_TEMP_ADDR))

/*CMD SELECT */
#define CMD_SELECT_MODE_NONE		(0x0 << 9)
#define CMD_SELECT_MODE_FIRST		(0x4 << 9)
#define CMD_SELECT_MODE_ID		(0x5 << 9)
#define CMD_SELECT_MODE_ALL		(0x6 << 9)
#define CMD_SELECT_MODE_LNKE		(0x7 << 9)

#define CMD_SELECT_NONE 		(SET_AB(WORD_CMD_3 | CMD_SELECT_MODE_NONE))
#define CMD_SELECT_FIRST 		(SET_AB(WORD_CMD_3 | CMD_SELECT_MODE_FIRST))
#define CMD_SELECT_ID(dpu_id)		(SET_AB(WORD_CMD_3 | CMD_SELECT_MODE_ID, | dpu_id))
#define CMD_SELECT_LNKE 		(SET_AB(WORD_CMD_3 | CMD_SELECT_MODE_LNKE))


/* CMD WRITE_REG */
#define CMD_WRITE_REG_ADDR_NODE_ID	(0x0 << 8)
#define CMD_WRITE_REG_ADDR_IGNORE	(0x3 << 8)

#define CMD_WRITE_REG_SET_ID(dpu_id)	(SET_MSB_PARITY(WORD_CMD_C | CMD_WRITE_REG_ADDR_NODE_ID | dpu_id))
#define CMD_WRITE_REG_UNSELECT_FIRST	(SET_MSB_PARITY(WORD_CMD_C | CMD_WRITE_REG_ADDR_IGNORE | 0x1))

/* CMD WRITE_REG_A */
#define CMD_WRITE_REG_ADDR_SPI_RECOVERY	(0x0 << 8)
#define SPI_RECOVERY_516		(0)
#define SPI_RECOVERY_260		(1)
#define SPI_RECOVERY_132		(2)
#define SPI_RECOVERY_4			(3)


#define CMD_WRITE_REG_A_SPI_RECOVERY(x)			(SET_MSB_PARITY(WORD_CMD_C | CMD_WRITE_REG_ADDR_SPI_RECOVERY | (x & 0x3)))

/* CMD NOP */
#define CMD_NOP				(WORD_CMD_E)

/* CMD RESUME*/
#define RESUME			(WORD_CMD_E)
#define BUBBLE			(0)

/* -------------------
 * Unsecure Sequences
 * -------------------
*/

/*
 * NR of BUBBLEs needed to overcome the SPI latency
 * we should not check the response for the BUBBLE
*/
#define SPI_DRAIN_BUBBLE_NR	(1)

/*
 * DPU shall be numbered in a specific older (1,0,2,3,4,5,7,6)
 * due to Local Interface constraints.
*/
const uint16_t gi_init_seq[] = {
    CMD_SELECT_FIRST, CMD_WRITE_REG_SET_ID(DPU_ID_1),
    CMD_WRITE_REG_UNSELECT_FIRST, CMD_SELECT_FIRST,
    CMD_WRITE_REG_SET_ID(DPU_ID_0), CMD_WRITE_REG_UNSELECT_FIRST,
    CMD_SELECT_FIRST, CMD_WRITE_REG_SET_ID(DPU_ID_2),
    CMD_WRITE_REG_UNSELECT_FIRST, CMD_SELECT_FIRST,
    CMD_WRITE_REG_SET_ID(DPU_ID_3), CMD_WRITE_REG_UNSELECT_FIRST,
    CMD_SELECT_FIRST, CMD_WRITE_REG_SET_ID(DPU_ID_4),
    CMD_WRITE_REG_UNSELECT_FIRST, CMD_SELECT_FIRST,
    CMD_WRITE_REG_SET_ID(DPU_ID_5), CMD_WRITE_REG_UNSELECT_FIRST,
    CMD_SELECT_FIRST, CMD_WRITE_REG_SET_ID(DPU_ID_7),
    CMD_WRITE_REG_UNSELECT_FIRST, CMD_SELECT_FIRST,
    CMD_WRITE_REG_SET_ID(DPU_ID_6), CMD_WRITE_REG_UNSELECT_FIRST,
    BUBBLE
};

const uint16_t gi_set_spi_recovery[] = {
    CMD_SELECT_LNKE, CMD_WRITE_REG_A_SPI_RECOVERY(SPI_RECOVERY_132),
    CMD_SELECT_NONE, CMD_NOP,
    BUBBLE
};

/*
* Ilink needs to close a cluster (word-signature, word-signature) in order to process a reading request,
* if two reading are in the same cluster the second would overwrite the first result.
* Build un-secure sequence with the same logic in order to make it as much as possible
* portable to secure scenario (signatures are anyway missed)
*/
#ifdef GI_ERROR
uint16_t spi_gi_lnke_status[] = {
#else
const uint16_t spi_gi_lnke_status[] = {
#endif
    CMD_GET_1RESULT_CHIP_ID_LSB, CMD_NOP,
    CMD_GET_1RESULT_CHIP_ID_MSB, CMD_NOP,
    CMD_GET_1RESULT_PLL_LOCK, CMD_NOP,
//    CMD_GET_1RESULT_CHIP_ID_LSB, CMD_NOP,
//    CMD_GET_1RESULT_CHIP_ID_MSB, CMD_NOP,
//    CMD_GET_1RESULT_CHECK_RES_OUTCOME, CMD_NOP,
//    CMD_GET_1RESULT_TEMP_CONF_DEFECT, CMD_NOP,
//    CMD_GET_1RESULT_TEMP, CMD_NOP,
    BUBBLE
    /* we should not check the response for the bubbles */
};


/* Due to RECOVERY CTRL setting we need 512 BUBBLEs at max */
const uint16_t bubble_seq[] = {
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
    BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE, BUBBLE,
};

const uint16_t resume_seq[] = {
    BUBBLE, BUBBLE, BUBBLE, RESUME, BUBBLE
};

#endif /* __GI_CMD_H__ */
